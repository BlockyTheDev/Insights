package net.frankheijden.insights.managers;

import io.papermc.lib.PaperLib;
import net.frankheijden.insights.Insights;
import net.frankheijden.insights.utils.*;
import org.bukkit.*;
import org.bukkit.block.Block;
import org.bukkit.configuration.file.YamlConfiguration;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.logging.Filter;
import java.util.logging.Logger;
import java.util.stream.Collectors;

public class TileManager {

    private static final Logger logger = Insights.logger;

    private static TileManager instance;
    private final Set<Material> tiles;

    public TileManager() {
        instance = this;
        this.tiles = new HashSet<>();
    }

    public static TileManager getInstance() {
        return instance;
    }

    public void tryRecalculateTiles(Location location) {
        File file = FileUtils.copyResourceIfNotExists("tiles.yml");
        YamlConfiguration yml = YamlConfiguration.loadConfiguration(file);

        String configVersion = yml.getString("last_updated");
        String mcVersion = "1." + PaperLib.getMinecraftVersion() + "." + PaperLib.getMinecraftPatchVersion();
        if (!mcVersion.equalsIgnoreCase(configVersion)) {
            this.tiles.addAll(recalculateTiles(location));
            configVersion = mcVersion;
        } else {
            for (String tile : yml.getStringList("tiles")) {
                try {
                    this.tiles.add(Material.valueOf(tile));
                } catch (IllegalStateException ex) {
                    logger.severe("Invalid Material '" + tile + "' in tiles.yml!");
                }
            }
        }

        yml.options().header("This file is automatically generated by Insights. Please don't modify it!\n"
                + "It contains a list of all tile entities which will be used by Insights to quickly lookup tile entity names.\n"
                + "This file was automatically generated on MC version " + configVersion + " and will be updated on newer minecraft versions.");
        yml.set("last_updated", configVersion);
        yml.set("tiles", stringValue(tiles));

        try {
            yml.save(file);
        } catch (IOException ex) {
            ex.printStackTrace();
        }

        logger.info(String.format("Recognized a total of %d tiles!", tiles.size()));
    }

    private List<String> stringValue(Set<Material> materials) {
        return materials.stream().map(Enum::name).collect(Collectors.toList());
    }

    public Set<Material> recalculateTiles(Location location) {
        logger.info("Started recalculating tiles! This may take some time...");
        Set<Material> tiles = new HashSet<>();

        Filter filterBackup = Bukkit.getLogger().getFilter();
        Bukkit.getLogger().setFilter(record -> false);

        Block block = location.getBlock();
        Material materialBackup = block.getType();
        for (Material m : Material.values()) {
            if (!m.isBlock()) continue;

            block.setType(m, false);
            if (TileUtils.isTile(block)) {
                tiles.add(m);
            }
        }
        block.setType(materialBackup);

        Bukkit.getLogger().setFilter(filterBackup);
        return tiles;
    }

    public Set<Material> getTiles() {
        return tiles;
    }

    public boolean isTile(Material material) {
        return tiles.contains(material);
    }
}
